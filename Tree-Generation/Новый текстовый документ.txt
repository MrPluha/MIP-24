package main

import (
	"errors"
	"math"
)

type Player int

const (
	USER Player = iota
	COMPUTER
)

type Game struct {
	currentPlayer Player
	currentNumber int
	totalPoints int
	bank        int
	visitedNodes int
	movesHistory []Move
}

type Move struct {
	player Player
	number int
}

func (g *Game) MakeMove(number int) error {
	if g.IsDivisible(number) {
		g.movesHistory = append(g.movesHistory, Move{g.currentPlayer, number})
		g.currentNumber /= number
		g.UpdatePoints()
		g.SwitchPlayer()
		return nil
	}
	return errors.New("Nepareizs gƒÅjiens")
}

func (g *Game) UpdatePoints() {
	if g.currentNumber%2 == 0 {
		g.totalPoints++
	} else {
		g.totalPoints--
	}

	lastDigit := g.currentNumber % 10
	if lastDigit == 0 || lastDigit == 5 {
		g.bank++
	}
}

func (g *Game) SwitchPlayer() {
	if g.currentPlayer == USER {
		g.currentPlayer = COMPUTER
	} else {
		g.currentPlayer = USER
	}
}

func (g *Game) IsGameOver() bool {
	for n := 3; n <= 5; n++ {
		if g.IsDivisible(n) {
			return false
		}
	}
	return true
}

func (g *Game) CalculateFinalScore() int {
	if g.totalPoints%2 == 0 {
		return g.totalPoints - g.bank
	}
	return g.totalPoints + g.bank
}

func (g *Game) EvaluateHeuristic() int {
	score := g.totalPoints
	bank := g.bank

	if g.currentNumber%2 == 0 {
		score++
	} else {
		score--
	}

	if g.currentNumber%10 == 0 || g.currentNumber%10 == 5 {
		bank++
	}

	if score%2 == 0 {
		score -= bank
	} else {
		score += bank
	}

	return score
}

func (g *Game) Minimax(depth int, maximizingPlayer bool) int {
	if depth == 0 || g.IsGameOver() {
		return g.EvaluateHeuristic()
	}

	if maximizingPlayer {
		maxEval := math.MinInt64
		for _, number := range []int{3, 4, 5} {
			if g.IsDivisible(number) {
				savedNumber := g.currentNumber
				g.currentNumber /= number
				eval := g.Minimax(depth-1, false)
				g.currentNumber = savedNumber
				if eval > maxEval {
					maxEval = eval
				}
				g.visitedNodes++
			}
		}
		return maxEval
	} else {
		minEval := math.MaxInt64
		for _, number := range []int{3, 4, 5} {
			if g.IsDivisible(number) {
				savedNumber := g.currentNumber
				g.currentNumber /= number
				eval := g.Minimax(depth-1, true)
				g.currentNumber = savedNumber
				if eval < minEval {
					minEval = eval
				}
				g.visitedNodes++
			}
		}
		return minEval
	}
}

func (g *Game) AlphaBeta(depth int, alpha, beta int, maximizingPlayer bool) int {
	if depth == 0 || g.IsGameOver() {
		return g.EvaluateHeuristic()
	}

	if maximizingPlayer {
		maxEval := math.MinInt64
		for _, number := range []int{3, 4, 5} {
			if g.IsDivisible(number) {
				savedNumber := g.currentNumber
				g.currentNumber /= number
				eval := g.AlphaBeta(depth-1, alpha, beta, false)
				g.currentNumber = savedNumber
				if eval > maxEval {
					maxEval = eval
				}
				alpha = max(alpha, eval)
				if beta <= alpha {
					break
				}
				g.visitedNodes++
			}
		}
		return maxEval
	} else {
		minEval := math.MaxInt64
		for _, number := range []int{3, 4, 5} {
			if g.IsDivisible(number) {
				savedNumber := g.currentNumber
				g.currentNumber /= number
				eval := g.AlphaBeta(depth-1, alpha, beta, true)
				g.currentNumber = savedNumber
				if eval < minEval {
					minEval = eval
				}
				beta = min(beta, eval)
				if beta <= alpha {
					break
				}
				g.visitedNodes++
			}
		}
		return minEval
	}
}

func (g *Game) IsDivisible(n int) bool {
	return g.currentNumber%n == 0
}

func max(a, b int) int {
	if a > b {
		return a
	}
	return b
}

func min(a, b int) int {
	if a < b {
		return a
	}
	return b
}
